{
  "hash": "22c5de284f9b0cd9d07cfba3ed45220a",
  "result": {
    "markdown": "---\ntitle: \"Data wrangling with 'dplyr' in R\"\nformat: html\nimage: tuto2.png\ndate: 07-12-23\n---\n\n\n#### *Prepared by Claire Lepault and Marie Sevestre* <br>\n\n`dplyr` offers a simple and consistent code syntaxe for data manipulation. We provide here short examples of the key `dplyr` verbs: `select()`, `filter()`, `arrange()`, `mutate()`, `summarize()` and `group_by()`.\n\n# To get started !\n\n## Ensure **tidyverse** is installed\n\nThe `dplyr` package is part of the [`tidyverse`](https://dplyr.tidyverse.org/) (Hadleyverse), and it follows a grammar-based approach to programming/data work. \n\nFirst, ensure **tidyverse** is installed : `install.packages('tidyverse')` <br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"tidyverse\") #Load the library \n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.2     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n\n```{.r .cell-code}\ntidyverse_packages() #Display the packages\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"broom\"         \"conflicted\"    \"cli\"           \"dbplyr\"       \n [5] \"dplyr\"         \"dtplyr\"        \"forcats\"       \"ggplot2\"      \n [9] \"googledrive\"   \"googlesheets4\" \"haven\"         \"hms\"          \n[13] \"httr\"          \"jsonlite\"      \"lubridate\"     \"magrittr\"     \n[17] \"modelr\"        \"pillar\"        \"purrr\"         \"ragg\"         \n[21] \"readr\"         \"readxl\"        \"reprex\"        \"rlang\"        \n[25] \"rstudioapi\"    \"rvest\"         \"stringr\"       \"tibble\"       \n[29] \"tidyr\"         \"xml2\"          \"tidyverse\"    \n```\n:::\n:::\n\n\n## The **pipe** operator\n\n\n### Pipes & dplyr\n\nPipes are a simplifying programming tool that make your code easier to read. In `dplyr`, the expression for a pipe is `%>%`.\n\n### What is a pipe ?\n\nPipes take the output of a function as the input/argument of another function. R's pipe specifically plugs the returned object to the left of the pipe into the first argument of the function on the right fo the pipe.\n\n<i>**Example: generate a random sample and obtain its mean**</i>\n\n::: {.cell}\n\n```{.r .cell-code}\nrnorm(10) %>%  #rnorm(n) generates a random sample of n observations from a normal distribution \n    mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.1418261\n```\n:::\n:::\n\n\nPipes avoid nested functions, prevent excessive writing to your disc, and increase the readability of our R scripts. By default, R pipes the output from the LHS of the pipe into\nthe first argument of the function on the RHS of the pipe. <br>\nFor example, `a %>% fun(3)` is equivalent of `fun(arg1=a, arg2 = 3)`\n\n## The **storms** database\n\nTo introduce `dplyr` verbs with pipes, we will use the **storms** database, which is the NOAA Atlantic hurricane database best track data. \nThe data includes the positions and attributes of storms from 1975-2021. Storms from 1979 onward are measured every six hours during the lifetime of the storms. \n\nIf you want to learn more about storms : \n\n::: {.cell}\n\n```{.r .cell-code}\n?storms\n```\n:::\n\n<i> **NB** : In the following sections, the **head(n)** and **tail(n)** functions are used for the presentation, to show only the first or last **n** or rows of the database.</i> \n\n\n::: {.cell}\n\n```{.r .cell-code}\nstorms %>%\n    head(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 13\n  name   year month   day  hour   lat  long status       category  wind pressure\n  <chr> <dbl> <dbl> <int> <dbl> <dbl> <dbl> <fct>           <dbl> <int>    <int>\n1 Amy    1975     6    27     0  27.5   -79 tropical de…       NA    25     1013\n2 Amy    1975     6    27     6  28.5   -79 tropical de…       NA    25     1013\n# ℹ 2 more variables: tropicalstorm_force_diameter <int>,\n#   hurricane_force_diameter <int>\n```\n:::\n:::\n\n\n# The five key `dplyr` verbs\n\nThere are five key dplyr verbs that you need to learn.\n\n* `select()`: Select (i.e. subset) columns by their names.\n\n* `filter()`: Filter (i.e. subset) rows based on their values.\n\n* `arrange()`: Arrange (i.e. reorder) rows based on their values.\n\n* `mutate()`: Create new columns.\n\n* `summarize()` and `group_by()`: Collapse multiple rows into a single summary value.\n\n<i>Let's practice these commands together using the storms data frame ! </i>\n\n## Select columns with `select()`\n\nIf you want to select specific columns of a dataframe, you can use **select()**.\n\n### Selection based on columns names\n\n* Use commas to select multiple columns out of a data frame:\n\n::: {.cell}\n\n```{.r .cell-code}\nstorms %>% \n    select(name, year, month, day, hour, wind, pressure)%>%\n    head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 7\n  name   year month   day  hour  wind pressure\n  <chr> <dbl> <dbl> <int> <dbl> <int>    <int>\n1 Amy    1975     6    27     0    25     1013\n2 Amy    1975     6    27     6    25     1013\n3 Amy    1975     6    27    12    25     1013\n4 Amy    1975     6    27    18    25     1013\n5 Amy    1975     6    28     0    25     1012\n```\n:::\n:::\n\n* You can use \"first:last\" for consecutive columns:\n\n::: {.cell}\n\n```{.r .cell-code}\nstorms %>% \n    select(name:hour, wind, pressure)%>%\n    head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 7\n  name   year month   day  hour  wind pressure\n  <chr> <dbl> <dbl> <int> <dbl> <int>    <int>\n1 Amy    1975     6    27     0    25     1013\n2 Amy    1975     6    27     6    25     1013\n3 Amy    1975     6    27    12    25     1013\n4 Amy    1975     6    27    18    25     1013\n5 Amy    1975     6    28     0    25     1012\n```\n:::\n:::\n\n* You can deselect a column with `-`:\n\n::: {.cell}\n\n```{.r .cell-code}\nstorms %>% \n    select(name:hour, wind, pressure, -day)%>%\n    head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 6\n  name   year month  hour  wind pressure\n  <chr> <dbl> <dbl> <dbl> <int>    <int>\n1 Amy    1975     6     0    25     1013\n2 Amy    1975     6     6    25     1013\n3 Amy    1975     6    12    25     1013\n4 Amy    1975     6    18    25     1013\n5 Amy    1975     6     0    25     1012\n```\n:::\n:::\n\n### Selection based on string characters\n\n**select(contains(PATTERN))** allows to select columns in a dataframe which contain a specific \"PATTERN\". It provides a nice shortcut in relevant cases: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nstorms %>% \n    select(name, contains(\"diameter\"))%>%\n    tail(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 3\n  name  tropicalstorm_force_diameter hurricane_force_diameter\n  <chr>                        <int>                    <int>\n1 Wanda                           60                        0\n2 Wanda                           60                        0\n3 Wanda                           90                        0\n4 Wanda                           90                        0\n5 Wanda                           70                        0\n```\n:::\n:::\n\nHere, we have selected the columns whose names contain the word \"diameter\".\n\n### Rename variables\n\nYou can also rename some (or all) of your selected variables in place:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstorms %>%\n    select(alias=name, year, month, day, hour, wind_speed=wind, ts_diameter=tropicalstorm_force_diameter)%>%\n    head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 7\n  alias  year month   day  hour wind_speed ts_diameter\n  <chr> <dbl> <dbl> <int> <dbl>      <int>       <int>\n1 Amy    1975     6    27     0         25          NA\n2 Amy    1975     6    27     6         25          NA\n3 Amy    1975     6    27    12         25          NA\n4 Amy    1975     6    27    18         25          NA\n5 Amy    1975     6    28     0         25          NA\n```\n:::\n:::\n\nIf you just want to rename columns without subsetting them, you can use rename:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstorms %>%\n    rename(alias=name, wind_speed=wind, ts_diameter=tropicalstorm_force_diameter)%>%\n    head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 13\n  alias  year month   day  hour   lat  long status  category wind_speed pressure\n  <chr> <dbl> <dbl> <int> <dbl> <dbl> <dbl> <fct>      <dbl>      <int>    <int>\n1 Amy    1975     6    27     0  27.5 -79   tropic…       NA         25     1013\n2 Amy    1975     6    27     6  28.5 -79   tropic…       NA         25     1013\n3 Amy    1975     6    27    12  29.5 -79   tropic…       NA         25     1013\n4 Amy    1975     6    27    18  30.5 -79   tropic…       NA         25     1013\n5 Amy    1975     6    28     0  31.5 -78.8 tropic…       NA         25     1012\n# ℹ 2 more variables: ts_diameter <int>, hurricane_force_diameter <int>\n```\n:::\n:::\n\n\n\n## Filter observations with `filter()`\n\nTo keep observations, that validate a particular condition, you can use **filter()**. \n\nWe can chain multiple filter commands with the pipe `%>%` or just separate them within a single filter command using commas:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstorms %>% \n    select(name,year,month,day)%>%\n    filter(year==2008,month >= 6)%>%\n    head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 4\n  name    year month   day\n  <chr>  <dbl> <dbl> <int>\n1 Arthur  2008     6     1\n2 Arthur  2008     6     1\n3 Arthur  2008     6     1\n```\n:::\n:::\n\nHere, we have selected the columns \"name\", \"year\", \"month\" and \"day\" thanks to **select()**. \nWith **filter()**, we keep row data with \"year\" equal to 2008 and \"month\" equal to or greater than six.   \n\n### Using logical operators\n\nWe can use the `&` (\"and\") and/or `|` (\"or\") logical operators:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstorms %>% \n    select(name,year,month,day)%>%\n    filter(year==2008 | month >= 6)%>%\n    head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 4\n  name   year month   day\n  <chr> <dbl> <dbl> <int>\n1 Amy    1975     6    27\n2 Amy    1975     6    27\n3 Amy    1975     6    27\n```\n:::\n:::\n\n### Using regular expressions \n\nThe **grepl()** function allows to find the pattern in a character string. \n\n::: {.cell}\n\n```{.r .cell-code}\nstorms %>% \n    select(name:status)%>%\n    filter(grepl(\"tropical\", status))%>%\n    head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 8\n  name   year month   day  hour   lat  long status             \n  <chr> <dbl> <dbl> <int> <dbl> <dbl> <dbl> <fct>              \n1 Amy    1975     6    27     0  27.5 -79   tropical depression\n2 Amy    1975     6    27     6  28.5 -79   tropical depression\n3 Amy    1975     6    27    12  29.5 -79   tropical depression\n4 Amy    1975     6    27    18  30.5 -79   tropical depression\n5 Amy    1975     6    28     0  31.5 -78.8 tropical depression\n```\n:::\n:::\n\nHere, we have kept the rows where the word \"tropical\" appears in the \"status\" column. \n<br>\n\n### Missing values\n\nA very common filter use case is identifying (or removing) missing data cases: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nstorms %>% \n    select(name,year,month,day,hour,ts_diameter=tropicalstorm_force_diameter)%>%\n    filter(is.na(ts_diameter))%>% \n    head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 6\n  name   year month   day  hour ts_diameter\n  <chr> <dbl> <dbl> <int> <dbl>       <int>\n1 Amy    1975     6    27     0          NA\n2 Amy    1975     6    27     6          NA\n3 Amy    1975     6    27    12          NA\n```\n:::\n:::\n\nHere, we have renamed the column \"tropicalstorm_force_diameter\" in \"ts_diameter\". \nThe use of the **filter()** function, with the **is.na()** function, allows to filter the rows where the \"ts_diameter\" columns is missing (=\"NA\"). \n\n* **To remove missing observations, simply use negation**: filter(**!is.na(**ts_diameter**)**)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstorms %>% \n    select(name,year,month,day,hour,ts_diameter=tropicalstorm_force_diameter)%>%\n    filter(!is.na(ts_diameter))%>% \n    head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 6\n  name   year month   day  hour ts_diameter\n  <chr> <dbl> <dbl> <int> <dbl>       <int>\n1 Alex   2004     7    31    18           0\n2 Alex   2004     8     1     0           0\n3 Alex   2004     8     1     6           0\n```\n:::\n:::\n\n\n## Sort data with `arrange()`\n\nYou can arrange your data according to a colums, with the **arrange()** function. \n\n::: {.cell}\n\n```{.r .cell-code}\nstorms %>% \n    select(name,year,month,day,hour,ts_diameter=tropicalstorm_force_diameter)%>%\n    filter(!is.na(ts_diameter))%>%\n    arrange(ts_diameter)%>%\n    head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 6\n  name   year month   day  hour ts_diameter\n  <chr> <dbl> <dbl> <int> <dbl>       <int>\n1 Alex   2004     7    31    18           0\n2 Alex   2004     8     1     0           0\n3 Alex   2004     8     1     6           0\n```\n:::\n:::\n\nHere, the **arrange()** function is used to sort the rows according to the \"ts_diameter\" columns, by ascensing order. \n\n### Descending order\n\nBy default, sorting will be organised by ascending order. We can also arrange items in descending order using `arrange(desc())`.\n\n::: {.cell}\n\n```{.r .cell-code}\nstorms %>% \n    select(name,year,month,day,hour,ts_diameter=tropicalstorm_force_diameter)%>%\n    filter(!is.na(ts_diameter))%>%\n    arrange(desc(ts_diameter))%>%\n    head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 6\n  name   year month   day  hour ts_diameter\n  <chr> <dbl> <dbl> <int> <dbl>       <int>\n1 Oscar  2018    11     3    12        1440\n2 Oscar  2018    11     3     6        1230\n3 Oscar  2018    11     3    18        1140\n```\n:::\n:::\n\n## Create news variable with `mutate()`\n\nYou can create new columns from scratch, or (more commonly) as transformations of existing columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstorms %>% \n    select(name, year, month, day) %>%\n    mutate(decade = paste0(substr(year, start = 1, stop = 3),0),\n           quarter = ifelse(month %in% c(12,1,2), \"Winter\",\n                        ifelse(month %in% 3:5, \"Spring\", \n                            ifelse(month %in% 6:8,\"Summer\",\"Automn\"))),\n            text = paste0(name, \" occured in the \", decade,\"'s\"))%>%\n    head(4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 7\n  name   year month   day decade quarter text                     \n  <chr> <dbl> <dbl> <int> <chr>  <chr>   <chr>                    \n1 Amy    1975     6    27 1970   Summer  Amy occured in the 1970's\n2 Amy    1975     6    27 1970   Summer  Amy occured in the 1970's\n3 Amy    1975     6    27 1970   Summer  Amy occured in the 1970's\n4 Amy    1975     6    27 1970   Summer  Amy occured in the 1970's\n```\n:::\n:::\n\n\nHere, we have created 3 columns :\n\n* \"decade\" is composed of the first three digits of the column year (extracted with the **substr()** function) followed by a 0 (concatenated to the first 3 digits thanks to the **paste0()** function).\n\n* \"quarter\" reprensents the quarter season based on the month value\n\n* \"text\" contains the concatenation of the name of the storm, the expression \"occurred in the\" and the corresponding decade.\n\nmutate is order aware. So you can chain multiple mutates in a single call.\n\n### mutate_if\n\n**mutate_if()** allows you to easily work on a subset of variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstorms %>% \n    select(name:status) %>% \n    mutate(status=as.character(status))%>%\n    mutate_if(is.character, toupper) %>% \n    head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 8\n  name   year month   day  hour   lat  long status             \n  <chr> <dbl> <dbl> <int> <dbl> <dbl> <dbl> <chr>              \n1 AMY    1975     6    27     0  27.5 -79   TROPICAL DEPRESSION\n2 AMY    1975     6    27     6  28.5 -79   TROPICAL DEPRESSION\n3 AMY    1975     6    27    12  29.5 -79   TROPICAL DEPRESSION\n4 AMY    1975     6    27    18  30.5 -79   TROPICAL DEPRESSION\n5 AMY    1975     6    28     0  31.5 -78.8 TROPICAL DEPRESSION\n```\n:::\n:::\n\n\nThe **toupper()** function converts a character string in uppercase. So with the **mutate_if(is.character)** function, here, if the columns of the storms dataframe are character strings, the **toupper()** function will be apply. \n\n### mutate_at & mutate_all\n\nmutate_at and mutate_all are also helpful.\n**mutate_at** allows to modify specified columns. The list argument enables to choose the suffix added to the name of the column that is \"mutated\". \n\n\n::: {.cell}\n\n```{.r .cell-code}\nstorms %>% \n    select(name:status) %>% \n    mutate_at(vars(name,status), list(UP =~ toupper(.))) %>% \n    head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 10\n  name   year month   day  hour   lat  long status             name_UP status_UP\n  <chr> <dbl> <dbl> <int> <dbl> <dbl> <dbl> <fct>              <chr>   <chr>    \n1 Amy    1975     6    27     0  27.5   -79 tropical depressi… AMY     TROPICAL…\n2 Amy    1975     6    27     6  28.5   -79 tropical depressi… AMY     TROPICAL…\n3 Amy    1975     6    27    12  29.5   -79 tropical depressi… AMY     TROPICAL…\n```\n:::\n:::\n\nHere, we have created the \"name_UP\" and \"status_UP\" columns, by converting the \"name\" and \"status\" column values in uppercase. \n\n## Agregate operations with `summarize()` and `group_by()`\n\n`summarize()` summarizes variables: you choose the variables and the summaries (e.g., mean() or min()). \nWhen using `group_by()`, summaries are done by groups:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstorms %>% \n    select(name, year, wind, pressure) %>%\n    mutate(decade = paste0(substr(year, start = 1, stop = 3),0))%>%\n    group_by(decade) %>%                                       # for each decade\n    summarize(Nobs = n(),                                      #number of observations\n              mean_wind = mean(wind, na.rm = TRUE),            #average wind speed\n              max_pressure = max(pressure, na.rm = TRUE))%>%   #maximum pressure\n    head(4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 4\n  decade  Nobs mean_wind max_pressure\n  <chr>  <int>     <dbl>        <int>\n1 1970     932      50.9         1015\n2 1980    2674      51.0         1018\n3 1990    3895      51.4         1020\n4 2000    5000      49.9         1024\n```\n:::\n:::\n\n\n* **Note that including \"na.rm = TRUE\" (or, its alias \"na.rm = T\") is usually a good idea with summarize functions. Otherwise, any missing value will propogate to the summarized value too.**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstorms %>% \n    summarize(mean_ts_diameter = mean(tropicalstorm_force_diameter))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n  mean_ts_diameter\n             <dbl>\n1               NA\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstorms %>%\n    summarize(mean_ts_diameter = mean(tropicalstorm_force_diameter, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n  mean_ts_diameter\n             <dbl>\n1             146.\n```\n:::\n:::\n\n\n### summarize_if, summarize_at and summarize_all\n\nThe same if-, at- and all-based workflow that we saw with mutate a few slides back also works with summarize.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstorms %>% \n    select(name, year, wind, pressure) %>%\n    mutate(decade = paste0(substr(year, start = 1, stop = 3),0))%>%\n    group_by(decade) %>% \n    summarize_if(is.numeric, mean, na.rm=T) %>%\n    head(4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 4\n  decade  year  wind pressure\n  <chr>  <dbl> <dbl>    <dbl>\n1 1970   1977.  50.9     995.\n2 1980   1985.  51.0     994.\n3 1990   1995.  51.4     993.\n4 2000   2004.  49.9     993.\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstorms %>% \n    select(year, wind, pressure) %>%\n    mutate(decade = paste0(substr(year, start = 1, stop = 3),0))%>%\n    select(-year)%>%group_by(decade) %>% \n    summarize_all(list(Mean=~mean(.,na.rm=TRUE), \n                       Min=~min(.,na.rm=TRUE),\n                       Max=~max(.,na.rm=TRUE)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 7\n  decade wind_Mean pressure_Mean wind_Min pressure_Min wind_Max pressure_Max\n  <chr>      <dbl>         <dbl>    <int>        <int>    <int>        <int>\n1 1970        50.9          995.       15          924      150         1015\n2 1980        51.0          994.       10          888      165         1018\n3 1990        51.4          993.       10          905      155         1020\n4 2000        49.9          993.       10          882      160         1024\n5 2010        49.0          994.       15          908      160         1021\n6 2020        47.8          995.       15          917      135         1018\n```\n:::\n:::\n\n\n# And more in **tidyverse**\n\nThere's more with `dplyr`:\n\n- Merging **inner_join()**,**left_join()**,**anti_join()**\n- Viewing data **glimpse()**, **top_n()**\n- Sampling **sample_n()**, **sample_frac()**\n- Summaries **first()**, **last()**, **nth()**, **n_distinct()**\n- Duplicates **distinct()**\n- Missingness **na_if()**\n\n`tidyr` offers useful tools too:\n\n- Missingness **replace_na()**, **drop_na()**, **fill()**\n- Tidying **pivot_longer()**, **pivot_wider()**\n\n\n### Acknowlegdments\nThis tutorial is inspired from great resources on data analysis and econometrics with R offered by [Ed Rubin](http://edrub.in/)([PhD Econometrics III](https://github.com/edrubin/EC607S23)) and [Grant Mac Dermott](https://grantmcdermott.com/) ([Data science for economists](https://github.com/uo-ec607/lectures)). \n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}